(function () {
'use strict';

if (document.createElement('dialog') instanceof HTMLUnknownElement && !HTMLElement.prototype.hasOwnProperty('open')) {
	HTMLElement.prototype.show = function() {
		this.open = true;
	};

	HTMLElement.prototype.close = function(returnValue = null) {
		this.open = false;
		if (this.tagName === 'DIALOG') {
			this.dispatchEvent(new CustomEvent('close', {detail: returnValue}));
		}
	};

	Object.defineProperty(HTMLElement.prototype, 'open', {
		set: function(open) {
			if (open) {
				this.setAttribute('open', '');
			} else {
				this.removeAttribute('open');
				if (this.tagName === 'DIALOG') {
					this.classList.remove('modal');
					const next = this.nextElementSibling;
					if (next instanceof HTMLElement && next.matches('.backdrop')) {
						next.remove();
					}
				}
			}
		},
		get: function() {
			return this.hasAttribute('open');
		}
	});
}
if (! document.createElement('dialog').hasOwnProperty('showModal')) {
	HTMLElement.prototype.showModal = function() {
		this.open = true;
		this.classList.add('modal');
		const backdrop = document.createElement('div');
		backdrop.classList.add('backdrop');
		this.after(backdrop);
	};
}

const PREFIXES = [
	'',
	'moz',
	'webkit',
	'ms'
];

/*============================ esQuery Functions =======================*/
class esQuery extends Set {
	constructor(selector, parent = document) {
		if (typeof selector === 'string') {
			super(parent.querySelectorAll(selector));
			if (parent instanceof HTMLElement && parent.matches(selector)) {
				this.add(parent);
			}
		} else if (
			selector instanceof NodeList
			|| selector instanceof HTMLCollection
			|| selector instanceof Array
		) {
			super(selector);
		} else if (typeof selector === 'object') {
			super();
			this.add(selector);
		} else {
			super();
			throw new TypeError(`Expected a string or NodeList but got a ${typeof selector}: ${selector}.`);
		}
	}

	get found() {
		return this.size !== 0;
	}

	async text(str) {
		this.forEach(node => node.textContent = str);
		return this;
	}

	async html(html) {
		this.forEach(node => node.innerHTML = html);
		return this;
	}

	async replaceText(replacements = {}) {
		this.forEach(el => Object.keys(replacements).forEach(find => {
			el.textContent = el.textContent.replace(find, replacements[find]);
		}));
		return this;
	}

	async visible() {
		return this.css({visibility: 'visible'});
	}

	async invisible() {
		return this.css({visibility: 'hidden'});
	}

	async each(callback, thisArg = this) {
		let n = 0;
		this.forEach(el => callback.call(thisArg, el, n++));
		return this;
	}

	/**
	 * Note: This is for `HTMLDialogElement.prototype.show`, not the inverse
	 * of `hide`
	 */
	async show() {
		this.forEach(node => {
			if ('show' in node) {
				node.show();
			}
		});
		return this;
	}

	async showModal() {
		this.forEach(node => {
			if ('showModal' in node) {
				node.showModal();
			}
		});
		return this;
	}

	async close() {
		this.forEach(node => {
			if ('close' in node) {
				node.close();
			}
		});
		return this;
	}

	async animate(keyframes, opts = 400) {
		if ('animate' in Element.prototype) {
			return Promise.all(await this.map(node => {
				return new Promise((resolve, reject) => {
					const anim = node.animate(keyframes, opts);
					anim.onfinish = () => resolve(node);
					anim.oncancel = reject;
				});
			})).then(els => new esQuery(els));
		} else {
			return Promise.resolve([]);
		}
	}

	async getAnimations() {
		let anims = [];
		this.forEach(el => {
			const elAnims = el.getAnimations();
			anims = anims.concat(elAnims);
		});
		return anims;
	}

	async playAnimations(...ids) {
		let anims = await this.getAnimations();
		anims.filter(anim => ids.includes(anim.id)).forEach(anim => anim.play());
		return this;
	}

	async pauseAnimations(...ids) {
		let anims = await this.getAnimations();
		anims.filter(anim => ids.includes(anim.id)).forEach(anim => anim.pause());
		return this;
	}

	async cancelAnimations(...ids) {
		const anims = await this.getAnimations();
		anims.filter(anim => ids.includes(anim.id)).forEach(anim => anim.cancel());
		return this;
	}

	async animateFilter({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 'none',
		to         = 'none',
		id         = 'grayscale',
	} = {}) {
		return this.animate([
			{filter: `${from}`},
			{filter: `${to}`},
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterDropShadow({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = '0 0 0 black',
		to         = '0.5em 0.5em 0.5em rgba(0,0,0,0.3)',
		id         = 'drop-shadow',
	} = {}) {
		return this.animate([
			{filter: `drop-shadow(${from})`},
			{filter: `drop-shadow(${to})`},
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterGrayscale({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'grayscale',
	} = {}) {
		return this.animateFilter({
			from: `grayscale(${from})`,
			to: `grayscale(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterBlur({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = '0px',
		to         = '5px',
		id         = 'blur',
	} = {}) {
		return this.animateFilter({
			from: `blur(${from})`,
			to: `blur(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterInvert({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = '100%',
		id         = 'invert',
	} = {}) {
		return this.animateFilter({
			from: `invert(${from})`,
			to: `invert(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterHueRotate({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = '0deg',
		to         = '90deg',
		id         = 'hue-rotate',
	} = {}) {
		return this.animateFilter({
			from: `hue-rotate(${from})`,
			to: `hue-rotate(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterBrightness({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'brightness',
	} = {}) {
		return this.animateFilter({
			from: `brightness(${from})`,
			to: `brightness(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterContrast({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'contrast',
	} = {}) {
		return this.animateFilter({
			from: `contrast(${from})`,
			to: `contrast(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterSaturate({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'saturate',
	} = {}) {
		return this.animateFilter({
			from: `saturate(${from})`,
			to: `saturate(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterOpacity({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'saturate',
	} = {}) {
		return this.animateFilter({
			from: `opacity(${from})`,
			to: `opacity(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterSepia({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'sepia',
	} = {}) {
		return this.animateFilter({
			from: `sepia(${from})`,
			to: `sepia(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async fade({
		duration   = 400,
		delay      = 0,
		fill       = 'forwards',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 1,
		to         = 0,
		id         = 'fade-in',
	} = {}) {
		return this.animate([
			{opacity: from},
			{opacity: to}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async fadeIn({
		duration   = 400,
		delay      = 0,
		fill       = 'forwards',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'fade-in',
	} = {}) {
		return this.fade({
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			from,
			to,
			id,
		});
	}

	async fadeOut(opts = {}) {
		return this.fade(opts);
	}

	async scale({
		duration     = 400,
		delay        = 0,
		fill         = 'both',
		direction    = 'normal',
		easing       = 'linear',
		iterations   = 1,
		id           = 'scale',
		initialScale = 0,
		scale        = 1.5,
	} = {}) {
		return this.animate([
			{transform: `scale(${initialScale})`},
			{transform: `scale(${scale})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async grow({
		duration     = 400,
		delay        = 0,
		fill         = 'both',
		direction    = 'normal',
		easing       = 'linear',
		iterations   = 1,
		id           = 'grow',
		initialScale = 0,
		scale        = 1,
	} = {}) {
		return this.scale({
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
			scale,
			initialScale,
		});
	}

	async shrink({
		duration     = 400,
		delay        = 0,
		fill         = 'both',
		direction    = 'normal',
		easing       = 'linear',
		iterations   = 1,
		id           = 'shrink',
		initialScale = 1,
		scale        = 0,
	} = {}) {
		return this.scale({
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
			scale,
			initialScale,
		});
	}

	async rotate({
		duration        = 400,
		delay           = 0,
		fill            = 'both',
		direction       = 'normal',
		easing          = 'linear',
		iterations      = 1,
		id              = 'rotate',
		rotation        = '1turn',
		initialRotation = '0turn',
	} = {}) {
		return this.animate([
			{transform: `rotate(${initialRotation})`},
			{transform: `rotate(${rotation})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async bounce({
		duration   = 400,
		delay      = 0,
		fill       = 'none',
		direction  = 'alternate',
		easing     = 'ease-in-out',
		iterations = 1,
		id         = 'bounce',
		height     = '-50px',
	} = {}) {
		return this.animate([
			{transform: 'none'},
			{transform: `translateY(${height})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async shake({
		duration   = 400,
		delay      = 0,
		fill       = 'none',
		direction  = 'alternate',
		easing     = 'cubic-bezier(.68,-0.55,.27,1.55)',
		iterations = 6,
		id         = 'shake',
		offsetX    = '60px',
		offsetY    = '20px',
		scale      = 0.9,
	} = {}) {
		return this.animate([
			{transform: 'none'},
			{transform: `translateY(${offsetY}) translateX(-${offsetX}) scale(${scale})`},
			{transform: 'none'},
			{transform: `translateY(-${offsetY}) translateX(${offsetX}) scale(${1/scale})`},
			{transform: 'none'},
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async slideLeft({
		duration     = 400,
		delay        = 0,
		fill         = 'forwards',
		direction    = 'normal',
		easing       = 'ease-in',
		iterations   = 1,
		id           = 'slide-left',
		initial      = 0,
		distance     = '50px',
	} = {}) {
		return this.animate([
			{transform: `translateX(${initial})`},
			{transform: `translateX(-${distance})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async slideRight({
		duration     = 400,
		delay        = 0,
		fill         = 'forwards',
		direction    = 'normal',
		easing       = 'ease-in',
		iterations   = 1,
		id           = 'slide-right',
		initial      = 0,
		distance     = '50px',
	} = {}) {
		return this.animate([
			{transform: `translateX(${initial})`},
			{transform: `translateX(${distance})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async slideUp({
		duration     = 400,
		delay        = 0,
		fill         = 'forwards',
		direction    = 'normal',
		easing       = 'ease-in',
		iterations   = 1,
		id           = 'slide-up',
		initial      = 0,
		distance     = '50px',
	} = {}) {
		return this.animate([
			{transform: `translateY(${initial})`},
			{transform: `translateY(-${distance})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async slideDown({
		duration     = 400,
		delay        = 0,
		fill         = 'forwards',
		direction    = 'normal',
		easing       = 'ease-in',
		iterations   = 1,
		id           = 'slide-down',
		initial      = 0,
		distance     = '50px',
	} = {}) {
		return this.animate([
			{transform: `translateY(${initial})`},
			{transform: `translateY(${distance})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async loadHTML(href) {
		const url = new URL(href, location.origin);
		const resp = await fetch(url);

		if (resp.ok) {
			const parser = new DOMParser();
			const html = await resp.text();
			const doc = parser.parseFromString(html, 'text/html');
			this.html(doc.body.innerHTML);
			return this;
		} else {
			throw new Error(`${resp.url} [${resp.status} ${resp.statusText}]`);
		}
	}

	async some(callback) {
		return [...this].some(callback);
	}

	async every(callback) {
		return [...this].every(callback);
	}

	async find(callback) {
		return [...this].find(callback);
	}

	async findAll(callback) {
		return this.filter(callback);
	}

	async map(callback) {
		return [...this].map(callback);
	}

	async filter(callback) {
		return new esQuery([...this].filter(callback));
	}

	async addClass(...classes) {
		this.forEach(el => el.classList.add(...classes));
		return this;
	}

	async removeClass(...classes) {
		this.forEach(el => el.classList.remove(...classes));
		return this;
	}

	async hasClass(cname) {
		return this.some(el => el.classList.contains(cname));
	}

	async toggleClass(cname, force) {
		if (typeof force !== 'undefined') {
			this.forEach(node => node.classList.toggle(cname, force));
		} else {
			this.forEach(node => node.classList.toggle(cname));
		}
		return this;
	}

	async replaceClass(cname1, cname2) {
		this.forEach(node => node.classList.replace(cname1, cname2));
		return this;
	}

	async pickClass(cname1, cname2, condition) {
		this.toggleClass(cname1, condition);
		this.toggleClass(cname2, ! condition);
		return this;
	}

	async remove() {
		this.forEach(el => el.remove());
		return this;
	}

	async empty(query = null) {
		if (typeof query === 'string') {
			this.forEach(node => [...node.children].forEach(child => {
				if (child.matches(query)) {
					child.remove();
				}
			}));
		} else {
			this.forEach(node => [...node.children].forEach(child => child.remove()));
		}
		return this;
	}

	async hide(hidden = true) {
		this.forEach(el => el.hidden = hidden);
		return this;
	}

	async unhide(shown = true) {
		return this.hide(! shown);
	}

	async append(...nodes) {
		this.forEach(el => el.append(...nodes));
		return this;
	}

	async prepend(...nodes) {
		this.forEach(el => el.prepend(...nodes));
		return this;
	}

	async before(...nodes) {
		this.forEach(el => el.before(...nodes));
		return this;
	}

	async after(...nodes) {
		this.forEach(el => el.after(...nodes));
		return this;
	}

	async afterBegin(text) {
		this.forEach(el => el.insertAdjacentHTML('afterbegin', text));
		return this;
	}

	async afterEnd(text) {
		this.forEach(el => el.insertAdjacentHTML('afterend', text));
		return this;
	}

	async beforeBegin(text) {
		this.forEach(el => el.insertAdjacentHTML('beforebegin', text));
		return this;
	}

	async beforeEnd(text) {
		this.forEach(el => el.insertAdjacentHTML('beforeend', text));
		return this;
	}

	async hasAttribute(attr) {
		return this.some(el => el.hasAttribute(attr));
	}

	async attr(attrs = {}) {
		this.forEach(node => {
			for (const [key, value] of Object.entries(attrs)) {
				switch (typeof(value)) {
				case 'string':
				case 'number':
					node.setAttribute(key, value);
					break;
				case 'boolean':
					value ? node.setAttribute(key, '') : node.removeAttribute(key);
					break;
				default:
					node.removeAttribute(key);
				}
			}
		});
		return this;
	}

	async data(props = {}) {
		this.forEach(node => {
			for (const [key, value] of Object.entries(props)) {
				if (value === false) {
					delete node.dataset[key];
				} else if (value === true || value === null) {
					node.dataset[key] = '';
				} else {
					node.dataset[key] = typeof(value) === 'string' ? value : JSON.stringify(value);
				}
			}
		});
		return this;
	}

	async pause() {
		this.forEach(media => media.pause());
		return this;
	}

	async read({
		pause = null,
		resume = null,
		cancel = null,
		scrollWith = false,
	}) {
		if (window.hasOwnProperty('speechSynthesis')) {
			if (pause instanceof HTMLButtonElement) {
				pause.addEventListener('click', () => {
					window.speechSynthesis.pause();
					pause.disabled = true;

					if (resume instanceof HTMLButtonElement) {
						resume.disabled = false;
					}
				});
			}

			if (resume instanceof HTMLButtonElement) {
				resume.addEventListener('click', () => {
					window.speechSynthesis.resume();
					resume.disabled = true;

					if (pause instanceof HTMLButtonElement) {
						pause.disabled = false;
					}

					if (cancel instanceof HTMLButtonElement) {
						cancel.disabled = false;
					}
				});
			}

			if (cancel instanceof HTMLButtonElement) {
				cancel.addEventListener('click', () => {
					window.speechSynthesis.cancel();
					cancel.disabled = true;
					new esQuery('.reading').removeClass('reading');

					if (resume instanceof HTMLButtonElement) {
						resume.disabled = false;
					}

					if (pause instanceof HTMLButtonElement) {
						pause.disabled = true;
					}
				});
			}

			const utterances = await this.map(async el => {
				return new Promise((resolve, reject) => {
					const reading = new SpeechSynthesisUtterance(el.textContent);
					reading.addEventListener('start', () => {
						el.classList.add('reading');
						if (scrollWith) {
							el.scrollIntoView({
								behavior: 'smooth',
								block: 'start',
							});
						}
					});
					reading.addEventListener('end', event => {
						el.classList.remove('reading');
						if (resume instanceof HTMLButtonElement) {
							resume.disabled = false;
						}

						if (pause instanceof HTMLButtonElement) {
							pause.disabled = true;
						}

						if (cancel instanceof HTMLButtonElement) {
							cancel.disabled = true;
						}

						resolve(event.target);
					});
					reading.addEventListener('error', event => reject(event.target));
					window.speechSynthesis.speak(reading);
				});
			});
			await Promise.all(utterances);
		} else {
			throw new Error('SpeechSynthesis is not supported');
		}
		return this;
	}

	/*==================== Listener Functions =================================*/
	async on(event, callback, ...args) {
		this.forEach(node => node.addEventListener(event, callback, ...args));
		return this;
	}

	async once(event, callback) {
		return this.on(event, callback, {once: true});
	}

	async off(event, callback) {
		this.forEach(node => node.removeEventListener(callback));
		return this;
	}

	async ready(callback, ...args) {
		this.on('DOMContentLoaded', callback, ...args);
		if (document.readyState !== 'loading') {
			this.forEach(node => {
				callback.bind(node)(new Event('DOMContentLoaded'));
			}, false);
		}
		return this;
	}

	async networkChange(callback, ...args) {
		return this.online(callback, ...args).offline(callback, ...args);
	}

	async playing(callback) {
		this.forEach(e => e.onplay = callback);
		return this;
	}

	async paused(callback) {
		this.forEach(e => e.onpause = callback, false);
		return this;
	}

	async visibilitychange(callback, ...args) {
		this.forEach(e => {
			PREFIXES.forEach(pre => {
				e.addEventListener(`${pre}visibilitychange`, callback, ...args);
			});
		}, false);
		return this;
	}

	async click(callback, ...args) {
		return this.on('click', callback, ...args);
	}

	async dblclick(callback, ...args) {
		this.on('dblclick', callback, ...args);
	}

	async contextmenu(callback, ...args) {
		return this.on('contextmenu', callback, ...args);
	}

	async keypress(callback, ...args) {
		return this.on('keypress', callback, ...args);
	}

	async keyup(callback, ...args) {
		return this.on('keyup', callback, ...args);
	}

	async keydown(callback, ...args) {
		return this.on('keydown', ...args);
	}

	async mouseenter(callback, ...args) {
		return this.on('mouseenter', callback, ...args);
	}

	async mouseleave(callback, ...args) {
		return this.on('mouseleave', callback, ...args);
	}

	async mouseover(callback, ...args) {
		return this.on('mouseover', callback, ...args);
	}

	async mouseout(callback, ...args) {
		return this.on('mouseout', callback, ...args);
	}

	async mousemove(callback, ...args) {
		return this.on('mousemove', callback, ...args);
	}

	async mousedown(callback, ...args) {
		return this.on('mousedown', callback, ...args);
	}

	async mouseup(callback, ...args) {
		return this.on('mouseup', callback, ...args);
	}

	async input(callback, ...args) {
		return this.on('input', callback, ...args);
	}

	async change(callback, ...args) {
		return this.on('change', callback, ...args);
	}

	async submit(callback, ...args) {
		return this.on('submit', callback, ...args);
	}

	async reset(callback, ...args) {
		return this.on('reset', callback, ...args);
	}

	async invalid(callback, ...args) {
		return this.on('invalid', callback, ...args);
	}

	async select(callback, ...args) {
		return this.on('select', callback, ...args);
	}

	async focus(callback, ...args) {
		return this.on('focus', callback, ...args);
	}

	async blur(callback, ...args) {
		return this.on('blur', callback, ...args);
	}

	async resize(callback, ...args) {
		return this.on('resize', callback, ...args);
	}

	async updateready(callback, ...args) {
		return this.on('updateready', ...args);
	}

	async load(callback, ...args) {
		this.on('load', callback, ...args);
		if (document.readyState === 'complete') {
			document.dispatchEvent(new Event('load'));
		}
		return this;
	}

	async unload(callback, ...args) {
		return this.on('unload', callback, ...args);
	}

	async beforeunload(callback, ...args) {
		return this.on('beforeunload', callback, ...args);
	}

	async abort(callback, ...args) {
		return this.on('abort', callback, ...args);
	}

	async error(callback, ...args) {
		return this.on('error', callback, ...args);
	}

	async scroll(callback, ...args) {
		return this.on('scroll', ...args);
	}

	async drag(callback, ...args) {
		return this.on('drag', callback, ...args);
	}

	async offline(callback, ...args) {
		return this.on('offline', callback, ...args);
	}

	async online(callback, ...args) {
		return this.on('online', callback, ...args);
	}

	async hashchange(callback, ...args) {
		return this.on('hashchange', callback, ...args);
	}

	/*visibilitychange(callback) {
		return this.on('visibilitychange', callback);
	}*/

	async popstate(callback, ...args) {
		return this.on('popstate', callback, ...args);
	}

	async pagehide(callback, ...args) {
		return this.on('pagehide', callback, ...args);
	}

	async watch(watching, options = [], attributeFilter = []) {
		/*https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver*/
		const watcher = new MutationObserver(mutations => {
			mutations.forEach(mutation => watching[mutation.type].call(mutation));
		});
		const obs = Object.keys(watching).concat(options).reduce((watch, event) => {
			watch[event] = true;
			return watch;
		}, {attributeFilter});
		this.forEach(el => watcher.observe(el, obs));
		return this;
	}

	/**
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver
	 */
	async intersect(callback, options = {}) {
		const observer = new IntersectionObserver(callback, options);
		this.forEach(node => observer.observe(node));
		return this;
	}

	async css(props = {}) {
		this.forEach(node => {
			Object.keys(props).forEach(prop => {
				node.style.setProperty(prop, props[prop]);
			});
		});
		return this;
	}
}

function $(selector, parent = document) {
	return new esQuery(selector, parent);
}



function query(selector, node = document) {
	let results = Array.from(node.querySelectorAll(selector));
	if (node.matches(selector)) {
		results.unshift(node);
	}
	return results;
}

var deprefix = function() {
	if (!('Notification' in window)) {
		window.Notification = window.notifications || window.webkitNotifications || window.oNotifications || window.msNotifications || false;
	}
	if (!('indexedDB' in window)) {
		window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB || false;
	}
	if (!('hidden' in document)) {
		document.hidden = document.webkitHidden || document.msHidden || document.mozHidden || false;
	}
	if (!('visibilityState' in document)) {
		document.visibilityState = document.webkitVisibilityState || document.msVisibilityState || document.mozVisibilityState || 'visible';
	}
	if (!('fullscreenElement' in document)) {
		document.fullscreenElement = document.mozFullScreenElement || document.webkitFullscreenElement || false;
	}
	if (!('requestAnimationFrame' in window)) {
		window.requestAnimationFrame = window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || false;
	}
	if (!('exitFullscreen' in Document.prototype)) {
		Document.prototype.exitFullscreen = document.mozCancelFullScreen || document.webkitCancelFullScreen || document.msCancelFullScreen || false;
	}
	if (!('requestFullscreen' in HTMLElement.prototype)) {
		HTMLElement.prototype.requestFullScreen = HTMLElement.prototype.mozRequestFullScreen || HTMLElement.prototype.webkitRequestFullScreen || false;
	}
};

// TODO: Remove JavaScript style & animations & create rules in core-css
/**
 * Configure Web Share API Shim with share params {url, icon, label}s
 * @param share {url, icon, label)[, {}, [...]]
 * @return Promise
 */
var webShareApi = (...shares) => {
	shares.forEach(share => share.url = new URL(share.url));
	if (! Navigator.prototype.hasOwnProperty('share')) {
		Navigator.prototype.share = ({
			text  = null,
			title = null,
			url   = null,
		} = {}) =>   new Promise((resolve, reject) => {
			const size   = 64;
			const dialog = document.createElement('dialog');
			const header = document.createElement('header');
			const close  = document.createElement('button');
			const body   = document.createElement('div');
			const msg    = document.createElement('b');
			const font   = 'Roboto, Helvetica, "Sans Seriff"';

			function closeDialog(event) {
				if (
					(event.type === 'click'
						&& ! event.target.matches('dialog[open],dialog[open] *')
					) || (event.type === 'keypress' && event.code === 'Escape')
				) {
					dialog.close('Share canceled');
				}
			}

			function closeHandler(event) {
				if (Element.prototype.hasOwnProperty('animate')) {
					const rects = dialog.getClientRects()[0];
					const anim = dialog.animate([
						{top: 0},
						{top: `-${rects.height}px`},
					], {
						duration: 400,
						easing:   'ease-out',
						fill:     'both',
					});
					anim.onfinish = () => dialog.remove();
					anim.onerror = () => dialog.remove();
					anim.oncancel = () => dialog.remove();
				} else {
					dialog.remove();
				}

				document.removeEventListener('keypress', closeDialog);
				document.removeEventListener('click', closeDialog);
				reject(new DOMException(event.detail));
			}

			if (text === null && title === null && url === null) {
				reject(new TypeError('No known share data fields supplied. If using only new fields (other than title, text and url), you must feature-detect them first.'));
			} else if (shares.length === 0) {
				reject(new Error('No shares configured'));
			} else {
				msg.textContent = 'Share via';
				close.title     = 'Close dialog';

				shares.forEach(share => {
					const link = document.createElement('a');
					const icon = new Image(size, size);

					if (share.url.searchParams.has('url')) {
						share.url.searchParams.set('url', url);
					} else if (share.url.searchParams.has('u')) {
						share.url.searchParams.set('u', url);
					}

					if (share.url.searchParams.has('title')) {
						share.url.searchParams.set('title', title);
					} else if (share.url.searchParams.has('t')) {
						share.url.searchParams.set('t', title);
					} else if (share.url.searchParams.has('subject')) {
						share.url.searchParams.set('subject', title);
					}

					if (share.url.searchParams.has('text')) {
						share.url.searchParams.set('text', text);
					} else if (share.url.searchParams.has('summary')) {
						share.url.searchParams.set('summary', text);
					} else if (share.url.searchParams.has('body')) {
						share.url.searchParams.set('body', `${text}\n${url}`);
					}

					link.style.setProperty('display', 'inline-block');
					link.style.setProperty('margin', '0.3em');
					link.style.setProperty('text-decoration', 'none');
					link.style.setProperty('color', '#626262');
					link.style.setProperty('text-align', 'center');
					link.style.setProperty('font-family', font);
					link.style.setProperty('font-size', '20px');

					link.target = '_blank';
					icon.src    = share.icon.toString();
					link.href   = share.url.toString();
					link.title  = share.label;

					link.append(icon, document.createElement('br'), share.label);
					body.append(link);

					link.addEventListener('click', () => {
						resolve();
						dialog.close();
					});
				});

				dialog.style.setProperty('display', 'block');
				dialog.style.setProperty('position' ,'fixed');
				dialog.style.setProperty('background', '#fefefe');
				dialog.style.setProperty('top', '0');
				dialog.style.setProperty('bottom', 'auto');
				dialog.style.setProperty('left', '0');
				dialog.style.setProperty('right', '0');
				dialog.style.setProperty('transform', 'none');
				dialog.style.setProperty('border-radius', '0 0 5px 5px');
				dialog.style.setProperty('max-height', '500px');

				header.style.setProperty('height', '47px');
				header.style.setProperty('line-height', '47px');
				header.style.setProperty('color', '#232323');
				header.style.setProperty('box-shadow', 'none');
				header.style.setProperty('border-bottom', '1px solid #d5d5d5');

				msg.style.setProperty('font-family', font);
				msg.style.setProperty('font-size', '24px');
				msg.style.setProperty('display', 'block');

				close.style.setProperty('float', 'right');
				close.style.setProperty('font-family', font);
				close.style.setProperty('font-weight', 'bold');
				close.style.setProperty('font-size', '16px');

				if (CSS.supports('width', 'fit-content')) {
					dialog.style.setProperty('width', 'fit-content');
				} else if (CSS.supports('width', '-moz-fit-content')) {
					dialog.style.setProperty('width', '-moz-fit-content');
				} else if (CSS.supports('width', '-webkit-fit-content')) {
					dialog.style.setProperty('width', '-webkit-fit-content');
				} else {
					dialog.style.setProperty('min-width', '320px');
				}

				header.append(close, msg);
				close.append('X');
				dialog.append(header);
				dialog.append(body);
				document.body.append(dialog);
				dialog.showModal();

				if (Element.prototype.hasOwnProperty('animate')) {
					const rects = dialog.getClientRects()[0];

					dialog.animate([
						{top: `-${rects.height}px`},
						{top: 0},
					], {
						duration: 400,
						easing:   'ease-out',
						fill:     'both',
					});
				}

				dialog.addEventListener('close', closeHandler, {once: true});
				document.addEventListener('keypress', closeDialog);
				document.addEventListener('click', closeDialog);
				close.addEventListener('click', () => {
					dialog.close('Share canceled');
				}, {once: true});
			}
		});
	}
};

const facebook = {
	url: new URL('https://www.facebook.com/sharer/sharer.php?u&t'),
	icon: new URL('/img/logos/Facebook.svg', location.origin),
	label: 'Facebook',
};

const twitter = {
	url: new URL('https://twitter.com/intent/tweet/?text&url'),
	icon: new URL('/img/logos/twitter.svg', location.origin),
	label: 'Twitter',
};

const googlePlus = {
	url: new URL('https://plus.google.com/share/?url'),
	icon: new URL('/img/logos/Google_plus.svg', location.origin),
	label: 'Google+',
};

const linkedIn = {
	url: new URL('https://www.linkedin.com/shareArticle/?title&summary&url'),
	icon: new URL('/img/logos/linkedin.svg', location.origin),
	label: 'LinkedIn',
};

const reddit = {
	url: new URL('https://www.reddit.com/submit/?url&title'),
	icon: new URL('/img/logos/Reddit.svg', location.origin),
	label: 'Reddit',
};


var shares = Object.freeze({
	facebook: facebook,
	twitter: twitter,
	googlePlus: googlePlus,
	linkedIn: linkedIn,
	reddit: reddit
});

/**
 * HTML API using data-* attributes
 */
function show() {
	const target = document.querySelector(this.dataset.show);
	target.show();
}

function showModal() {
	const target = document.querySelector(this.dataset.showModal);
	target.showModal();
}

function close() {
	const target = document.querySelector(this.dataset.close);
	if (this.dataset.hasOwnProperty('returnValue')) {
		target.close(this.dataset.returnValue);
	} else {
		target.close();
	}
}

function scrollTo() {
	const target = document.querySelector(this.dataset.scrollTo);
	target.scrollIntoView({
		behaviour: 'smooth',
		block: 'start'
	});
}

function remove() {
	const targets = document.querySelectorAll(this.dataset.remove);
	targets.forEach(target => target.remove());
}

function fullscreen() {
	document.querySelector(this.dataset.fullscreen).requestFullscreen();
}



function toggleHidden() {
	document.querySelectorAll(this.dataset.toggleHidden).forEach(el => {
		el.hidden = ! el.hidden;
	});
}

function share(event) {
	event.preventDefault();
	event.stopPropagation();
	const containerEl = this.dataset.share === '' ? this : document.querySelector(this.dataset.share);
	let url = location.href, text = '', title = document.title;

	if (containerEl instanceof HTMLImageElement) {
		url = containerEl.src;
		title = containerEl.alt;
	} else if (containerEl instanceof HTMLAnchorElement) {
		url = containerEl.href;
		title = containerEl.title;
		text = containerEl.textContent;
	} else if (containerEl instanceof Element) {
		const urlEl = containerEl.closest('[itemtype]')
			.querySelector('[itemprop="url"], [itemprop="contentUrl"], [rel="canonical"]');
		const titleEl = containerEl.closest('[itemtype]')
			.querySelector('[itemprop="name"], [itemprop="headline"], title');
		const textEl = containerEl.closest('[itemtype]')
			.querySelector('[itemprop="description"], [name="description"]');

		if (urlEl instanceof Element) {
			if (urlEl.hasAttribute('content')) {
				url = urlEl.getAttribute('content');
			} else if (urlEl.hasAttribute('href')) {
				url = urlEl.href;
			} else {
				url = urlEl.textContent;
			}
		} else {
			url = location.href;
		}

		if (titleEl instanceof Element) {
			if (titleEl.hasAttribute('content')) {
				title = titleEl.getAttribute('content');
			} else {
				title = titleEl.textContent;
			}
		} else {
			title = document.title;
		}

		if (textEl instanceof Element) {
			if (textEl.hasAttribute('content')) {
				text = textEl.getAttribute('content');
			} else {
				text = textEl.textContent;
			}
		}
	}

	navigator.share({
		url: new URL(url, location.origin).toString(),
		title,
		text,
	}).catch(console.error);
}

const observer = new IntersectionObserver(lazyLoad, {rootMargin: '500px 0px 0px 0px'});

function infiniteScroll(entries, observer) {
	entries.filter(entry => entry.isIntersecting).forEach(async entry => {
		observer.unobserve(entry.target);
		const url = new URL(entry.target.dataset.infiniteScroll, location.origin);
		try {
			const resp = await fetch(url);
			if (url.searchParams.has('page')) {
				url.searchParams.set('page', parseInt(url.searchParams.get('page')) + 1);
				entry.target.dataset.infiniteScroll = url;
			}
			if (resp.ok) {
				const parser = new DOMParser();
				const html = await resp.text();
				const doc = parser.parseFromString(html, 'text/html');

				if (url.hash !== '') {
					entry.target.before(doc.getElementById(url.hash.substring(1)));
				} else {
					entry.target.before(...doc.body.childNodes);
				}
				observer.observe(entry.target);
			} else {
				throw new Error(`${resp.url} [${resp.status} ${resp.statusText}]`);
			}
		} catch (error) {
			console.error(error);
			observer.observe(entry.target);
		}
	});
}

function lazyLoad(entries, observer) {
	entries.filter(entry => entry.isIntersecting).forEach(async entry => {
		try {
			const url = new URL(entry.target.dataset.loadFrom, location.href);
			const resp = await fetch(url);
			if (resp.ok) {
				const parser = new DOMParser();
				const html = await resp.text();
				const content =  parser.parseFromString(html, 'text/html');
				entry.target.append(...content.body.childNodes);
			} else {
				throw new Error(`${resp.url} [${resp.status} ${resp.statusText}]`);
			}
		} catch (error) {
			console.error(error);
		} finally {
			observer.unobserve(entry.target);
			delete entry.target.dataset.loadFrom;
		}
	});
}

function toggleDetails() {
	const details = this.closest('details');
	details.open != details.open;
}






function init(base = document.body) {
	$('[data-show]', base).click(show);
	$('[data-show-modal]', base).click(showModal);
	$('[data-close]', base).click(close);
	$('[data-remove]', base).click(remove);
	$('[data-toggle-hidden]', base).click(toggleHidden);
	// $('[data-schema-content]', base).each(importSchema);
	$('[data-share]', base).click(share);
	$('[data-fullscreen]', base).click(fullscreen);
	$('[data-scroll-to]', base).click(scrollTo);
	$('[data-infinite-scroll]', base).intersect(infiniteScroll);
	$('[data-load-from]', base).each(node => observer.observe(node));

	if (document.createElement('details') instanceof HTMLUnknownElement) {
		$('details > summary').click(toggleDetails);
	}
}

/*
Add this as a listener on keypress events
*/
var kbdShortcuts = event => {
	if (event.target.matches('[contenteditable="true"], [contenteditable="true"] *')) {
		switch (event.key.toLowerCase()) {
		case 'y':
			if (event.ctrlKey && !(event.altKey || event.shiftKey)) {
				event.preventDefault();
				event.stopPropagation();
				document.execCommand('redo');
			}
			break;
		case 'z':
			if (event.ctrlKey && !(event.altKey || event.shiftKey)) {
				event.preventDefault();
				event.stopPropagation();
				document.execCommand('undo');
			}
			break;
		case 'a':
			if (event.ctrlKey && !(event.altKey || event.shiftKey)) {
				event.preventDefault();
				event.stopPropagation();
				document.execCommand('selectall');
			}
			break;
		case 'e':
			if (event.ctrlKey && !(event.altKey || event.shiftKey)) {
				event.preventDefault();
				event.stopPropagation();
				document.execCommand('justifyCenter');
			}
			break;
		case 'l':
			if (event.ctrlKey && !(event.altKey || event.shiftKey)) {
				event.preventDefault();
				event.stopPropagation();
				document.execCommand('justifyLeft');
			}
			break;
		case 'r':
			if (event.ctrlKey && !(event.altKey || event.shiftKey)) {
				event.preventDefault();
				event.stopPropagation();
				document.execCommand('justifyRight');
			}
			break;
		case 'j':
			if (event.ctrlKey && !(event.altKey || event.shiftKey)) {
				event.preventDefault();
				event.stopPropagation();
				document.execCommand('justiyFull');
			}
			break;
		case 'i':
			if (event.ctrlKey && !(event.altKey || event.shiftKey)) {
				event.preventDefault();
				event.stopPropagation();
				document.execCommand('styleWithCSS', null, false);
				document.execCommand('italic');
			}
			break;
		case 'b':
			if (event.ctrlKey && !(event.altKey || event.shiftKey)) {
				event.preventDefault();
				event.stopPropagation();
				document.execCommand('styleWithCSS', null, false);
				document.execCommand('bold');
			}
			break;
		case 'u':
			if (event.ctrlKey && !(event.altKey || event.shiftKey)) {
				event.preventDefault();
				event.stopPropagation();
				document.execCommand('styleWithCSS', null, false);
				document.execCommand('underline');
			}
			break;
		case 'k':
			if (event.ctrlKey && !(event.altKey || event.shiftKey)) {
				event.preventDefault();
				event.stopPropagation();
				document.execCommand('styleWithCSS', null, false);
				document.execCommand('strikethrough');
			}
			break;
		case 'tab':
			event.preventDefault();
			event.stopPropagation();
			document.execCommand(event.shiftKey ? 'outdent' : 'indent');
			break;
		}
	}
};

function getSelectedElement(matching = '[contenteditable="true"] *') {
	let selected = getSelection().anchorNode;
	while(! (selected instanceof HTMLElement)) {
		selected = selected.parentElement;
	}

	if (selected.matches('[contenteditable="true"] *')) {
		return selected;
	} else {
		throw new Error('Attempting to edit an element that is not editable');
	}
}

function editorCommand(click) {
	click.preventDefault();
	document.execCommand('styleWithCSS', null, click.target.dataset.hasOwnProperty('styleWithCss'));
	let arg = null;
	if (click.target.dataset.hasOwnProperty('editorValue')) {
		arg = click.target.dataset.editorValue;
	} else if (click.target.dataset.hasOwnProperty('prompt')) {
		arg = prompt(click.target.dataset.prompt.toString());
	} else if (click.target.dataset.hasOwnProperty('selectionTo')) {
		let createdEl = document.createElement(this.dataset.selectionTo);
		createdEl.textContent = getSelection().toString();
		arg = createdEl.outerHTML;
	}
	document.execCommand(this.dataset.editorCommand, null, arg);
}

function addClass(click) {
	click.preventDefault();
	const cname = prompt('Enter class name to add');
	if (addClass.length !== 0) {
		getSelectedElement().classList.add(cname);
	}
}

function removeClass(click) {
	click.preventDefault();
	const cname = prompt('Enter class name to remove');
	if (removeClass.length !== 0) {
		const el = getSelectedElement();
		el.classList.remove(cname);
		if (el.classList.length === 0) {
			el.removeAttribute('class');
		}
	}
}

function setAttribute(click) {
	click.preventDefault();
	const name = prompt('Enter attribute name');
	if (name.length !== 0) {
		const value = prompt('Enter attribute value');
		getSelectedElement().setAttribute(name, value.toString());
	}
}

function removeAttribute(click) {
	click.preventDefault();
	const attr = prompt('Enter name of attribute to remove');
	if (attr.length !== 0) {
		getSelectedElement().removeAttribute(attr);
	}
}

function saveWork(click) {
	click.preventDefault();
	localStorage.setItem('savedDoc', document.querySelector('[contenteditable="true"]').innerHTML);
}

function restoreWork(click) {
	click.preventDefault();
	document.querySelector('[contenteditable="true"]').innerHTML = localStorage.getItem('savedDoc');
}

function embedYouTube(click) {
	click.preventDefault();
	const yt = prompt('Enter YouTube video URL');
	if (yt) {
		const url = new URL(yt, 'https://www.youtube.com/watch');
		if (url.searchParams.has('v')) {
			const iframe = document.createElement('iframe');
			url.pathname = `/embed/${url.searchParams.get('v')}`;
			url.searchParams.delete('v');
			iframe.width = 560;
			iframe.height = 315;
			iframe.src = url;
			iframe.setAttribute('frameborder', '0');
			iframe.setAttribute('allowfullscreen', '');
			document.execCommand('inserthtml', null, iframe.outerHTML);
		}
	}
}

var wysiwyg = menu => {
	/* Do not use NodeList.forEach */
	query('[data-editor-command]', menu).forEach(item =>  {
		item.addEventListener('click', editorCommand);
	});
	query('[label="Add Class"]', menu).forEach(menuitem => {
		menuitem.addEventListener('click', addClass);
	});
	query('[label="Remove Class"]', menu).forEach(menuitem => {
		menuitem.addEventListener('click', removeClass);
	});
	query('[label="Set Attribute"]', menu).forEach(menuitem => {
		menuitem.addEventListener('click', setAttribute);
	});
	query('[label="Remove Attribute"]', menu).forEach(menuitem => {
		menuitem.addEventListener('click',removeAttribute);
	});
	query('[label="Save Work"]', menu).forEach(item => {
		item.addEventListener('click', saveWork);
	});
	query('[label="Restore Work"]', menu).forEach(item => {
		item.addEventListener('click', restoreWork);
	});
	query('[data-embed="youtube"]', menu).forEach(item => {
		item.addEventListener('click', embedYouTube);
	});
};

async function readFiles(files, readAs = 'dataURI') {
	return Promise.all([...files].map(async file => {
		return new Promise((resolve, reject) => {
			const reader = new FileReader();
			reader.addEventListener('load', event => resolve(event.target.result));
			reader.addEventListener('error', event => reject(event.target));
			switch(readAs) {
			case 'dataURI':
				reader.readAsDataURL(file);
				break;
			case 'binary':
				reader.readAsBinaryString(file);
				break;
			case 'arrayBuffer':
				reader.readAsArrayBuffer(file);
				break;
			case 'text':
				reader.readAsText(file);
				break;
			default:
				throw new Error(`Unknown read format, ${readAs}`);
			}
		});
	}));
}
function dragEnterHandler(event) {
	event.preventDefault();
	this.classList.add('receiving');
}

function dragExitHandler(event) {
	event.preventDefault();
	this.classList.remove('receiving');
}

function dataURI(event) {
	event.preventDefault();
	this.classList.remove('receiving');

	if (event.dataTransfer.files.length !== 0) {
		readFiles(event.dataTransfer.files, 'dataURI').then(files => {
			files.forEach(uri => document.execCommand('insertImage', false, uri));
		}).catch(console.error);
	}
}

class ImageDrop {
	static dataURI(el) {
		el.addEventListener('dragenter', dragEnterHandler);
		el.addEventListener('dragexit', dragExitHandler);
		el.addEventListener('drop', dataURI);
	}
}

async function readyHandler() {
	init();
	const $doc = $(document.documentElement);
	$doc.replaceClass('no-js', 'js');
	$('[contenteditable="true"]').keypress(kbdShortcuts);
	$('[contenteditable="true"]').each(ImageDrop.dataURI);

	if (Navigator.prototype.hasOwnProperty('share')) {
		$('[data-share]').attr({hidden: false});
	}

	$doc.click(event => {
		if (! event.target.matches('details[open], details[open] *')) {
			$('details[open].js-auto-close').close();
		}
	});

	$('.toolbar').each(wysiwyg);

	if (HTMLElement.prototype.hasOwnProperty('contextMenu')) {
		const resp = await fetch(new URL('./wysiwyg.html', location.href));
		const parser = new DOMParser();
		const html = await resp.text();
		const doc = parser.parseFromString(html, 'text/html');
		wysiwyg(doc.body.firstElementChild);
		const editor = document.querySelector('[contenteditable="true"]');
		editor.setAttribute('contextmenu', doc.body.firstElementChild.id);
		document.body.appendChild(doc.body.firstElementChild);
	}
}

webShareApi(...Object.values(shares));
deprefix();

$(self).ready(readyHandler, {once: true});

}());
//# sourceMappingURL=index.min.js.map
